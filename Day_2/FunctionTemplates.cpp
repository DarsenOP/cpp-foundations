//
// Created by DarsenOP on 2/2/25.
//

/* Function Templates */

#include <iostream>
#include <cstring>

template <typename T>
T maximum(T a, T b)
{
    T result = (a > b) ? a : b;
    std::cout << result << std::endl;
    return result;
}

template <>
const char* maximum<const char*>(const char* a, const char* b)
{
    return (std::strcmp(a, b) > 0) ? a : b;
}

int main()
{
    // It is just a function blueprint
    int int_value1{1};
    int int_value2{29};

    double double_value1{1.1};
    double double_value2{4.25};

    std::string_view string_value1{"Hello"};
    std::string_view string_value2{"World"};

    maximum(int_value1, int_value2);
    maximum(double_value1, double_value2);
    maximum(string_value1, string_value2);

    // Templates are blueprints not a C++ code. The compiler generates the needed code when the function is called,
    // looking at the arguments and choosing the type needed

    // The real C++ code generated by the compiler is called template instance

    // The template instance will be reused when a similar function call is issued. No duplicates are generated

    // Template type deduction

    maximum<double>(int_value1, double_value2);

    // Templates can also be pass by reference
    // Template specialization

    const char* g{"wild"};
    const char* f{"animal"};
    std::cout << maximum(f, g);

    return 0;
}